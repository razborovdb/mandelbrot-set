# Class Applications: The Mandelbrot Set

### Background
The Manbdelbrot set is an infinitely complex, and yet self-similar
fractal made by a simple mathematical rule. 

It was first visualized in 1979, when computer graphics were starting
to become more available to mathematicians. The discovery helped
birth the field of fractal geometry, which has been used in a variety
of applications including art, file compression, to human health.

See the Appendix at the bottom of this README for more information
about this set, why it's interesting, and what it represents.

The set is generated by applying a recursive rule to each coordinate
in the complex plane.

<h3> Z<sub>n+1</sub> = Z<sub>n</sub><sup>2</sup> + C </h3>

Where both Z and C are complex numbers.

When the formula is repeated several times (each time is called an
"iteration"), one of two things happen.
Either the value shoots off into infinity, or the value bounces around
between two finite boundaries. We will be coloring each coordinate
based on how many iterations the value lasts before shooting off.

## What you will be doing

The graphical logic is already built for you. It requires some topics
we have not covered yet in the course. Your role will be that of a
programmer who is tasked with creating the complex number class 
necessary for the graphics team to build the visualization.

You have been given instructions from the mathematics team on what the
formula should do, and so your role will be to program a method which
performs the necessary calculation.


## Your Tasks

### Create the Complex Number Class, Cnum

Create a new class named Cnum.

Complex numbers in mathematics make use of the imaginary number "i",
and take the form `a + bi`.

We cannot use the number `i` directly. So instead our class needs only
to keep track to the two real values, `a` and `b`.

- Create these two fields along with a constructor which populates them.
- Create a default constructor which sets both `a` and `b` to 0.
- Create Getters and Setters for both fields.

## Complete the Methods Inside of the Main Class

### Creating Complex Number Arithmetic Operations

We aren't able to add two `Cnum`s together using the `+` operator. Nor
can we square them. So the math team won't be able to use our class
directly themselves. Instead, you'll need to design a method which 
computes the algorithm programmatically.

*For help with creating these methods and understanding algebra with 
complex numbers, see the `Concepts` section below.*

- `float getCnumMagnitude(Cnum)` Takes in a Cnum and returns its
magnitude

- `Cnum ZnPlusOne(Cnum Zn, Cnum C)` Takes in two complex numbers
and computes the next iteration of the Mandelbrot function.
    - Zn<sup>2</sup> + C
    
## A Completed Project Will:

Display the Mandelbrot set as pictured below:

## Extensions 1

Modify the `Mandelbrot()` method to allow for panning and zoom.

Panning can be done using the `translate()` method and you can use Processing's 
`mouseDragged` method for catching the input.

Zooming can be mathematically difficult if you want it to zoom in around a specific
point outside of (0, 0). The range of values considered is defined in the for loop
of the Mandelbrot method.

## Extensions 2

For curious students, look up Julia sets. These are a more generalized form of the
equation we used in this lesson. With Julia sets, you can modify the initial
conditions to animate the set. Check out 
[this animation](https://en.wikipedia.org/wiki/Julia_set#/media/File:JSr07885.gif)
from the Wikipedia article. Keep in mind only the initial values for the equation
are changed between each frame, once you have one set, you have access to all of them.

## Appendix A: Math Concepts

### Recursive Math Functions

Let's look at an equation of the form:

<code>
X<sub>n+1</sub> = 2 * X<sub>n</sub> + 1
</code>

Imagine we are told that X<sub>0</sub> = 4 and we need to find X<sub>1</sub>.

<pre>
X<sub>1</sub> = 2X<sub>0</sub> + 1
X<sub>1</sub> = 2*4 + 1
X<sub>1</sub> = 8 + 1
X<sub>1</sub> = 9
</pre>

Now we can find X<sub>2</sub> which equals 2X<sub>1</sub> + 1

<pre>
X<sub>2</sub> = 2*9 + 1
X<sub>2</sub> = 18 + 1
X<sub>2</sub> = 19
</pre>

This was the first two iterations of our example equation.

Our program will perform a number of iterations according to the value
of the `DETAIL` variable at the top of the class. The starting value
is 25 iterations. If the value has not shot up towards infinity by 25
iterations, the pixel will be purple. The fewer iterations it takes,
the redder the pixel's hue.

In our program, we are using Cnums instead of integers, and will be
squaring instead of multiplying by 2.

Z<sub>n+1</sub> = Z<sub>n</sub>² + C

Where C corresponds to the pixel's coordinate on the screen.

### Adding Cnums

To add two complex numbers we must add the two real numbers, and the
two imaginary numbers.

For example

```
(1 + 2i) + (3 - 4i)
= (1+3) + (2-4)i
= 4 - 2i
```

More generally

```
(a + bi) + (c + di)
= (a+c) + (b+d)i
```

### Multiplying Cnums

Our formula requires us to square a Cnum. We'll think of this as
multiplying a Cnum together with itself. This is very similar to
multiplying polynomials but with one special rule.

The complex number `i` stands for the square root of -1. Don't worry
if you are unfamiliar with this concept. The bottom line is that
by definition `i² == -1`.

```
(a + bi) * (c + di)

//Cross multiply each term
(ac + adi) + (bci + bd*i²)

//Remember that i*i equals -1
ac + adi + bci + bd*(-1)

//Simplify
ac + adi + bci - bd

//Group Real and Imaginary terms
(ac - bd) + (ad + bc)i
```

The bottom line is the formula we desire for `Cnum` multiplication.
Since we are only squaring `Cnum`s in our project, we can simplify 
more by setting:

`a == c` and `b == d`

```
//We're really starting with
(a + bi) * (a + bi)

//Cross multiply
(a² + abi + abi + b²i²)

//Cnum(a,b)² is:
(a² - b²) + (2ab)i
```

### Magnitude of Complex Numbers

We've been talking about making sure our value does not shoot off 
to infinity. With complex numbers we have both a Real component
`a`, and an Imaginary component `b`. Either of these can grow 
infinitely.

So we instead look at the **magnitude** of the entire number. We
can get this value by finding the distance to the origin `(0,0)`.

```java
√(a² + b²)
```

## Appendix B: What is the Mandelbrot set?

### Significance on a Macro scale

The significance of the set really helped kick start the field of chaos
theory in mathematics. We're looking at an infinitely complex fractal pattern
which emerges from a simple iterative rule. If the rule changes even slightly,
the entire set can change drastically.

If you zoom in to the mandelbrot set its complexity becomes compounds. Unlike
a self-similar fractal such as the Sierpinski Triangle, the fractals in the
Mandelbrot set do not repeat with any regularity. Check out [this video](https://www.youtube.com/watch?v=VPHbgHVxLYY)
and click around a bit. You'll see how different this shape looks at different
levels of zoom. But the most fascinating bit occurs at the end, where the entire
set reappears but at a different angle.

This phenomenon serves as an allegory to a repeated theme in the study of chaos.
Consider a complex system such as the climate, where a small change in initial
conditions can cause drastically different outcomes (the butterfly effect).
One's initial reaction may be to throw up their hands and say "forget it" we
can't make perfect measurements, and so we cannot predict the outcome with any
certainty (think of how the weather channel reports rain and how often they are
completely wrong). It turns out though, that in its own strange way, there tends
to be patterns among chaos. It may be daunting to see the Mandelbrot set in its
infinite complexity, but then come to find that the equation behind it is relatively
simple.

If this interests you, there is a great story-based layman's book by James Gleick, 
*Chaos: Making a New Science* that has a lot more to say on the history and 
applications of Chaos theory.

### What are we looking at on a micro scale?

What's going on in the mandelbrot set on your screen, is like a little game. Keep in
mind that it takes place on the complex plane, so we are using complex numbers for
our coordinates. We take any number on the plane and plug it into the equation. It gives
us a new number, and we plug that into the same equation and so on.

When you do this a few times, one of two things happen. Either the value shoots off to
infinity, or it stabilizes on a value. Values tend to bounce around a bit before we can
tell if they are going to settle down or if they are going to shoot off (converge or diverge).
Coordinates that converge are in the set, and those that diverge to infinity are out of 
the set.

The color of each pixel on the screen it determined by the number of iterations its
coordinate "survives" when playing the game. Numbers that instantly fly off are colored red.
Those that bounce around a few times before diverging are bluer and may be green or yellow.
Numbers that survive some number of iterations, say, 25, are colored purple and are solidly in
the set.

We have options to change things such as the number of iterations we require a value to survive
before declaring it is officially in the set. The more iterations we allow, the longer the
computation time, but the higher fidelity we get. It might be fun to try changing this value in
your program and see how the runtime and clarity of the set change.
